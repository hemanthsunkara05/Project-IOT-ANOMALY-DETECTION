<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Live Sensor Dashboard</title>
    <link rel="stylesheet" href="/static/style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <h1>üìä Live Sensor Dashboard</h1>

        <!-- Anomaly Alert Box -->
        <div id="anomaly-alert" style="display: none; color: red; font-weight: bold;">
            üö® Anomaly Detected in Sensor Data!
        </div>
        <!-- Optional sound -->
        <audio id="anomaly-sound" src="/static/anomaly.mp3" preload="auto"></audio>

        <div class="center">
            <a class="download-btn" href="/download">‚¨áÔ∏è Download CSV</a>
        </div>

        <label for="sensorFilter">Select Sensor Type:</label>
        <select id="sensorFilter">
            <option value="all">All</option>
            <option value="MQ-5">MQ-5</option>
            <option value="Temperature">Temperature</option>
            <option value="Humidity">Humidity</option>
        </select>

        <canvas id="sensorChart" width="800" height="400"></canvas>

        <table id="data-table">
            <thead>
                <tr>
                    <th>Sensor ID</th>
                    <th>Value</th>
                    <th>Timestamp</th>
                </tr>
            </thead>
            <tbody>
                <!-- Data will be populated here -->
            </tbody>
        </table>
    </div>

    <script>
let myChart;

// Helper: assign color to sensor
function getColor(sensor) {
    const colors = {
        'MQ-5': 'red',
        'Temperature': 'blue',
        'Humidity': 'green'
    };
    return colors[sensor] || 'gray';
}

async function fetchData() {
    const response = await fetch('/dashboard-data');
    const data = await response.json();
    console.log("Data from backend:", data);

    // Apply sensor filter
    const selectedSensor = document.getElementById('sensorFilter').value;
    const filtered = selectedSensor === 'all'
        ? data
        : data.filter(d => d.sensor_type === selectedSensor);

    // Group by sensor type
    const sensorGroups = {};
    filtered.forEach(d => {
        if (!sensorGroups[d.sensor_type]) {
            sensorGroups[d.sensor_type] = {
                timestamps: [],
                values: [],
                anomalies: []
            };
        }
        sensorGroups[d.sensor_type].timestamps.push(d.timestamp);
        sensorGroups[d.sensor_type].values.push(d.value);
        sensorGroups[d.sensor_type].anomalies.push(d.anomaly);
    });

    const datasets = Object.keys(sensorGroups).map(sensor => {
        const group = sensorGroups[sensor];
        return {
            label: sensor,
            data: group.timestamps.map((t, i) => ({ x: t, y: group.values[i] })),
            borderColor: getColor(sensor),
            borderWidth: 2,
            fill: false,
            pointRadius: group.anomalies.map(a => a === 1 ? 6 : 3),
            pointBackgroundColor: group.anomalies.map(a => a === 1 ? 'red' : getColor(sensor))
        };
    });

    if (myChart) {
        myChart.data.datasets = datasets;
        myChart.update();
    } else {
        const ctx = document.getElementById('sensorChart').getContext('2d');
        myChart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: datasets
            },
            options: {
                responsive: true,
                parsing: false,
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            tooltipFormat: 'MMM D, h:mm:ss a',
                            unit: 'minute',
                            displayFormats: {
                                minute: 'h:mm a'
                            }
                        },
                        title: {
                            display: true,
                            text: 'Time'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Value'
                        }
                    }
                }
            }
        });
    }

    // Anomaly Alert
    const anyAnomaly = filtered.some(row => row.anomaly === 1);
    document.getElementById("anomaly-alert").style.display = anyAnomaly ? "block" : "none";
    if (anyAnomaly) {
        document.getElementById("anomaly-sound").play();
    }
}

    setInterval(fetchData, 10000); // every 10 seconds
// Sensor type filter
document.getElementById('sensorFilter').addEventListener('change', fetchData);

// Auto refresh
setInterval(fetchData, 10000);
fetchData(); // Load on page load
</script>

</body>
</html>